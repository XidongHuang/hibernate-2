package com.tony.hibernate.entities;

import static org.junit.Assert.*;

import java.util.Date;

import org.hibernate.LazyInitializationException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class HibernateTest {

	private SessionFactory sessionFactory;
	private Session session;
	private Transaction transation;

	@Before
	public void init() {

		Configuration configuration = new Configuration().configure();
		
		StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()
		        .configure( "hibernate.cfg.xml" )
		        .build();		
		Metadata metadata = new MetadataSources(standardRegistry).getMetadataBuilder().build();
		
		sessionFactory = metadata.getSessionFactoryBuilder().build();
		
		session = sessionFactory.openSession();
		transation = session.beginTransaction();
	}

	@After
	public void destory() {

		transation.commit();
		session.close();
		sessionFactory.close();
	
	}
	

	/**
	 * get VS load:
	 * 
	 * 1. Execute "get" method: It will be loading immediately. (Immediately Query)
	 * 	  But "load" method will not, it will return an agent object instead of searching
	 * 	  (Delay Query)
	 * 
	 * 2. If there are no corresponding records in data table and "Session" is closed
	 * 	  "get" returns "null"
	 * 	  "load" throws an "exception" if it tries to instance the object;
	 * 	   it will be fine if it does not use the object.
	 * 
	 * 3. "load" method may throw "LazyInitializationException"
	 * 	   Because "Session" is closed before agent object being instance
	 */
	
	@Test
	public void testLoad(){
		
		
		News news = session.load(News.class, 10);
		System.out.println(news.getClass().getName());
		
//		session.close();
//		
//		System.out.println(news);
		
		
	}
	
	
	@Test
	public void testGet(){
		News news = session.get(News.class, 2);
//		session.close();
		System.out.println(news);
		
		
	}
	
	
	
	/**
	 * The difference between persist() and save()
	 * 
	 * If an object has "id" before invoking persist(), then it will not execute
	 * INSERT sql, instead of throwing an exception
	 * 
	 */
	@Test
	public void testPersist(){
		
		News news = new News();
		news.setTitle("EE");
		news.setAuthor("ee");
		news.setDate(new Date());
		news.setId(200);
		
		
		session.persist(news);
		
	}
	
	
	
	
	/**
	 * 1. save() method:
	 * a) Change a transient object to persist object 
	 * b) Assign a ID to objects
	 * c) send a INSERT sql when doing flush() method
	 * d) 
	 * 
	 */
	@Test
	public void testSave(){
		
		News news = new News();
//		news.setTitle("AA");
//		news.setAuthor("aa");
		news.setTitle("BB");
		news.setAuthor("bb");
		news.setId(100);
		news.setDate(new Date());
		System.out.println(news);
		session.save(news);
		System.out.println(news);
		news.setId(15);
	}
	
	
	/**
	 * 
	 * clear(): clear cache
	 * 
	 * 
	 */
	@Test
	public void testClear(){
		News news1 =  session.get(News.class, 2);
		
		session.clear();
		
		News news2 =  session.get(News.class, 2);
		
		
	}
	
	
	@Test
	public void testRefresh(){
		News news = session.get(News.class, 2);
		System.out.println(news);

		session.refresh(news);
		System.out.println(news);
		
		
	}
	
	
	/**
	 * flush: Keeps database table's records are same as Session's cache. For keeping same, may send corresponding sql.
	 * 1. Invoke Transaction's commit() method:invoke session's flush() method first, then send transaction
	 * 2. flush() method may send SQL, but will not send transaction
	 * 3. Notice: Before "session" submits transaction or invokes session.flush(), it may operate flush() action.
	 * 		a.  For the last data tables' record,it will be executing HQL or QBC first. 
	 * 		b. If record's id is generated by "native", then after invoke save(), it will sent INSERT sql right away.
	 * 			Because after save, there must ensure the object's ID existing.  
	 * 
	 */
	@Test
	public void testSessionFlush2(){
		News news = new News("Java","SUN",new Date());
		session.save(news);
		
		
	}
	
	
	@Test
	public void testSessionFlush(){
		News news = session.get(News.class, 1);
		news.setAuthor("SUN");
//		
//		session.flush();
//		System.out.println("flush");
		
		News news2 = (News) session.createCriteria(News.class).uniqueResult();
		
		System.out.println(news2);
		
		
	}

	@Test
	public void testSessionCache() {
		
		News news = session.get(News.class, 1);
		System.out.println(news);
		
		News news2 = session.get(News.class, 1);
		System.out.println(news2);

	}

}
